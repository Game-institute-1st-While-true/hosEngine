// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HOSPACKETHEADER_HOS_PACKET_H_
#define FLATBUFFERS_GENERATED_HOSPACKETHEADER_HOS_PACKET_H_

#include "flatbuffers/flatbuffers.h"

namespace hos {
namespace Packet {

struct Vector3;

struct base_header;
struct base_headerBuilder;

struct hos_protocol;
struct hos_protocolBuilder;

struct hos_move_protocol;
struct hos_move_protocolBuilder;

enum hos_object_type {
  hos_object_type_scene_manager = 0,
  hos_object_type_scene = 1,
  hos_object_type_remote_func = 2,
  hos_object_type_MIN = hos_object_type_scene_manager,
  hos_object_type_MAX = hos_object_type_remote_func
};

inline const hos_object_type (&EnumValueshos_object_type())[3] {
  static const hos_object_type values[] = {
    hos_object_type_scene_manager,
    hos_object_type_scene,
    hos_object_type_remote_func
  };
  return values;
}

inline const char * const *EnumNameshos_object_type() {
  static const char * const names[4] = {
    "scene_manager",
    "scene",
    "remote_func",
    nullptr
  };
  return names;
}

inline const char *EnumNamehos_object_type(hos_object_type e) {
  if (flatbuffers::IsOutRange(e, hos_object_type_scene_manager, hos_object_type_remote_func)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameshos_object_type()[index];
}

enum hos_scene_protocol_type {
  hos_scene_protocol_type_HELLO = 0,
  hos_scene_protocol_type_GOODBYE = 1,
  hos_scene_protocol_type_IN = 2,
  hos_scene_protocol_type_IN_RESUT = 3,
  hos_scene_protocol_type_INFO = 4,
  hos_scene_protocol_type_CHAT = 5,
  hos_scene_protocol_type_MIN = hos_scene_protocol_type_HELLO,
  hos_scene_protocol_type_MAX = hos_scene_protocol_type_CHAT
};

inline const hos_scene_protocol_type (&EnumValueshos_scene_protocol_type())[6] {
  static const hos_scene_protocol_type values[] = {
    hos_scene_protocol_type_HELLO,
    hos_scene_protocol_type_GOODBYE,
    hos_scene_protocol_type_IN,
    hos_scene_protocol_type_IN_RESUT,
    hos_scene_protocol_type_INFO,
    hos_scene_protocol_type_CHAT
  };
  return values;
}

inline const char * const *EnumNameshos_scene_protocol_type() {
  static const char * const names[7] = {
    "HELLO",
    "GOODBYE",
    "IN",
    "IN_RESUT",
    "INFO",
    "CHAT",
    nullptr
  };
  return names;
}

inline const char *EnumNamehos_scene_protocol_type(hos_scene_protocol_type e) {
  if (flatbuffers::IsOutRange(e, hos_scene_protocol_type_HELLO, hos_scene_protocol_type_CHAT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameshos_scene_protocol_type()[index];
}

enum hos_game_object_protocol_type {
  hos_game_object_protocol_type_HELLO = 0,
  hos_game_object_protocol_type_GOODBYE = 1,
  hos_game_object_protocol_type_INFO = 2,
  hos_game_object_protocol_type_LIST = 3,
  hos_game_object_protocol_type_MOVE = 4,
  hos_game_object_protocol_type_ATTACK = 5,
  hos_game_object_protocol_type_MIN = hos_game_object_protocol_type_HELLO,
  hos_game_object_protocol_type_MAX = hos_game_object_protocol_type_ATTACK
};

inline const hos_game_object_protocol_type (&EnumValueshos_game_object_protocol_type())[6] {
  static const hos_game_object_protocol_type values[] = {
    hos_game_object_protocol_type_HELLO,
    hos_game_object_protocol_type_GOODBYE,
    hos_game_object_protocol_type_INFO,
    hos_game_object_protocol_type_LIST,
    hos_game_object_protocol_type_MOVE,
    hos_game_object_protocol_type_ATTACK
  };
  return values;
}

inline const char * const *EnumNameshos_game_object_protocol_type() {
  static const char * const names[7] = {
    "HELLO",
    "GOODBYE",
    "INFO",
    "LIST",
    "MOVE",
    "ATTACK",
    nullptr
  };
  return names;
}

inline const char *EnumNamehos_game_object_protocol_type(hos_game_object_protocol_type e) {
  if (flatbuffers::IsOutRange(e, hos_game_object_protocol_type_HELLO, hos_game_object_protocol_type_ATTACK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameshos_game_object_protocol_type()[index];
}

enum MOVE_DIR {
  MOVE_DIR_N = 0,
  MOVE_DIR_S = 1,
  MOVE_DIR_W = 2,
  MOVE_DIR_E = 3,
  MOVE_DIR_N_W = 4,
  MOVE_DIR_N_E = 5,
  MOVE_DIR_S_W = 6,
  MOVE_DIR_S_E = 7,
  MOVE_DIR_STOP = 8,
  MOVE_DIR_MIN = MOVE_DIR_N,
  MOVE_DIR_MAX = MOVE_DIR_STOP
};

inline const MOVE_DIR (&EnumValuesMOVE_DIR())[9] {
  static const MOVE_DIR values[] = {
    MOVE_DIR_N,
    MOVE_DIR_S,
    MOVE_DIR_W,
    MOVE_DIR_E,
    MOVE_DIR_N_W,
    MOVE_DIR_N_E,
    MOVE_DIR_S_W,
    MOVE_DIR_S_E,
    MOVE_DIR_STOP
  };
  return values;
}

inline const char * const *EnumNamesMOVE_DIR() {
  static const char * const names[10] = {
    "N",
    "S",
    "W",
    "E",
    "N_W",
    "N_E",
    "S_W",
    "S_E",
    "STOP",
    nullptr
  };
  return names;
}

inline const char *EnumNameMOVE_DIR(MOVE_DIR e) {
  if (flatbuffers::IsOutRange(e, MOVE_DIR_N, MOVE_DIR_STOP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMOVE_DIR()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3() {
    memset(static_cast<void *>(this), 0, sizeof(Vector3));
  }
  Vector3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 12);

struct base_header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef base_headerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_PROTOCOL = 6
  };
  uint16_t size() const {
    return GetField<uint16_t>(VT_SIZE, 4);
  }
  uint16_t protocol() const {
    return GetField<uint16_t>(VT_PROTOCOL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SIZE) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL) &&
           verifier.EndTable();
  }
};

struct base_headerBuilder {
  typedef base_header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint16_t size) {
    fbb_.AddElement<uint16_t>(base_header::VT_SIZE, size, 4);
  }
  void add_protocol(uint16_t protocol) {
    fbb_.AddElement<uint16_t>(base_header::VT_PROTOCOL, protocol, 0);
  }
  explicit base_headerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  base_headerBuilder &operator=(const base_headerBuilder &);
  flatbuffers::Offset<base_header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<base_header>(end);
    return o;
  }
};

inline flatbuffers::Offset<base_header> Createbase_header(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t size = 4,
    uint16_t protocol = 0) {
  base_headerBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  builder_.add_size(size);
  return builder_.Finish();
}

struct hos_protocol FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef hos_protocolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPPER_PROTOCOL = 4,
    VT_TYPE = 6,
    VT_INDEX = 8,
    VT_FUNC_TABLE_INDEX = 10,
    VT_LEVEL = 12,
    VT_RESULT_CODE = 14
  };
  const hos::Packet::base_header *upper_protocol() const {
    return GetPointer<const hos::Packet::base_header *>(VT_UPPER_PROTOCOL);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint16_t index() const {
    return GetField<uint16_t>(VT_INDEX, 0);
  }
  uint16_t func_table_index() const {
    return GetField<uint16_t>(VT_FUNC_TABLE_INDEX, 0);
  }
  bool level() const {
    return GetField<uint8_t>(VT_LEVEL, 0) != 0;
  }
  uint8_t result_code() const {
    return GetField<uint8_t>(VT_RESULT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPPER_PROTOCOL) &&
           verifier.VerifyTable(upper_protocol()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_INDEX) &&
           VerifyField<uint16_t>(verifier, VT_FUNC_TABLE_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_CODE) &&
           verifier.EndTable();
  }
};

struct hos_protocolBuilder {
  typedef hos_protocol Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upper_protocol(flatbuffers::Offset<hos::Packet::base_header> upper_protocol) {
    fbb_.AddOffset(hos_protocol::VT_UPPER_PROTOCOL, upper_protocol);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(hos_protocol::VT_TYPE, type, 0);
  }
  void add_index(uint16_t index) {
    fbb_.AddElement<uint16_t>(hos_protocol::VT_INDEX, index, 0);
  }
  void add_func_table_index(uint16_t func_table_index) {
    fbb_.AddElement<uint16_t>(hos_protocol::VT_FUNC_TABLE_INDEX, func_table_index, 0);
  }
  void add_level(bool level) {
    fbb_.AddElement<uint8_t>(hos_protocol::VT_LEVEL, static_cast<uint8_t>(level), 0);
  }
  void add_result_code(uint8_t result_code) {
    fbb_.AddElement<uint8_t>(hos_protocol::VT_RESULT_CODE, result_code, 0);
  }
  explicit hos_protocolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  hos_protocolBuilder &operator=(const hos_protocolBuilder &);
  flatbuffers::Offset<hos_protocol> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<hos_protocol>(end);
    return o;
  }
};

inline flatbuffers::Offset<hos_protocol> Createhos_protocol(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<hos::Packet::base_header> upper_protocol = 0,
    uint8_t type = 0,
    uint16_t index = 0,
    uint16_t func_table_index = 0,
    bool level = false,
    uint8_t result_code = 0) {
  hos_protocolBuilder builder_(_fbb);
  builder_.add_upper_protocol(upper_protocol);
  builder_.add_func_table_index(func_table_index);
  builder_.add_index(index);
  builder_.add_result_code(result_code);
  builder_.add_level(level);
  builder_.add_type(type);
  return builder_.Finish();
}

struct hos_move_protocol FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef hos_move_protocolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL = 4,
    VT_FOWARD = 6,
    VT_ROTATION = 8,
    VT_DIRECTION = 10,
    VT_DASH = 12
  };
  const hos::Packet::hos_protocol *protocol() const {
    return GetPointer<const hos::Packet::hos_protocol *>(VT_PROTOCOL);
  }
  const hos::Packet::Vector3 *foward() const {
    return GetStruct<const hos::Packet::Vector3 *>(VT_FOWARD);
  }
  const hos::Packet::Vector3 *rotation() const {
    return GetStruct<const hos::Packet::Vector3 *>(VT_ROTATION);
  }
  hos::Packet::MOVE_DIR direction() const {
    return static_cast<hos::Packet::MOVE_DIR>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool dash() const {
    return GetField<uint8_t>(VT_DASH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyTable(protocol()) &&
           VerifyField<hos::Packet::Vector3>(verifier, VT_FOWARD) &&
           VerifyField<hos::Packet::Vector3>(verifier, VT_ROTATION) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_DASH) &&
           verifier.EndTable();
  }
};

struct hos_move_protocolBuilder {
  typedef hos_move_protocol Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol(flatbuffers::Offset<hos::Packet::hos_protocol> protocol) {
    fbb_.AddOffset(hos_move_protocol::VT_PROTOCOL, protocol);
  }
  void add_foward(const hos::Packet::Vector3 *foward) {
    fbb_.AddStruct(hos_move_protocol::VT_FOWARD, foward);
  }
  void add_rotation(const hos::Packet::Vector3 *rotation) {
    fbb_.AddStruct(hos_move_protocol::VT_ROTATION, rotation);
  }
  void add_direction(hos::Packet::MOVE_DIR direction) {
    fbb_.AddElement<int8_t>(hos_move_protocol::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  void add_dash(bool dash) {
    fbb_.AddElement<uint8_t>(hos_move_protocol::VT_DASH, static_cast<uint8_t>(dash), 0);
  }
  explicit hos_move_protocolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  hos_move_protocolBuilder &operator=(const hos_move_protocolBuilder &);
  flatbuffers::Offset<hos_move_protocol> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<hos_move_protocol>(end);
    return o;
  }
};

inline flatbuffers::Offset<hos_move_protocol> Createhos_move_protocol(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<hos::Packet::hos_protocol> protocol = 0,
    const hos::Packet::Vector3 *foward = 0,
    const hos::Packet::Vector3 *rotation = 0,
    hos::Packet::MOVE_DIR direction = hos::Packet::MOVE_DIR_N,
    bool dash = false) {
  hos_move_protocolBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_foward(foward);
  builder_.add_protocol(protocol);
  builder_.add_dash(dash);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline const hos::Packet::hos_protocol *Gethos_protocol(const void *buf) {
  return flatbuffers::GetRoot<hos::Packet::hos_protocol>(buf);
}

inline const hos::Packet::hos_protocol *GetSizePrefixedhos_protocol(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<hos::Packet::hos_protocol>(buf);
}

inline bool Verifyhos_protocolBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<hos::Packet::hos_protocol>(nullptr);
}

inline bool VerifySizePrefixedhos_protocolBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<hos::Packet::hos_protocol>(nullptr);
}

inline void Finishhos_protocolBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<hos::Packet::hos_protocol> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedhos_protocolBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<hos::Packet::hos_protocol> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Packet
}  // namespace hos

#endif  // FLATBUFFERS_GENERATED_HOSPACKETHEADER_HOS_PACKET_H_
